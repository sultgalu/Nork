Program Events: Before/After Render, OnNewFrame -> camera canContr. can update it's VP on this.
Store VP (with any other common render data) in ubo. Need Render Api (like lightStorage) for this stuff
	-> Need separate (from win's) eventMan for these, events need to get called on raising (frameEventMan or smt)
	-> OR add method SubscribeForImmadiate() and have to sep. func. vectors

Make Event Categories. eg. WindowClose should not be INPUT. 
	-> Make EventManager templated by these categories
CameraController will need a parameter that has AppEvents, so it can listen to onUpdate().
	Or make onUpdate() method and call from outside?

REMOVE ECS::REGISTRY. Just use entt, no wrapping needed it's whatever.
rename Renderer::Data::* -> RawData::*, APIData::*, ResourceData::* OR Data::Raw::*, Data::API::*, Data::Resource::*

Polygons: use faces with unique normals + edges only around the faces 
	-> gen triangles for renderer (order face idxs)
	-> converting to collider should be trivial (no conversions)
		-> change the GPU / CPU collision detection accordingly.
			-> new branch for GPU assignment
		-> handle rotation
			-> angular momentum handling should be fine already
			-> contact point generation should be improved.
				-> with new system, clipping should give stable results
				-> probably check the book first

FRUSTUM CULLING:
	- generate frustums once (on frustumCount change
	- move stuff to shared 
	- use early depth pass (gPass) for z-culling

REFACTOR NOTES:
	-no namespace deeper than 2 (Nork::Renderer->end it here) -> makes modular style more visible
	- Viewport: owns camera. Runtime choose camController.
	- Make PanelData for every Panel (MainPanelData), so it can be serialized pl.
	- SceneRenderer: Gets Scene& and draws it. Get result from its data. Every Instance has unique framebuffers (could share some)